#include "arduino_secrets.h"
/*
  Sketch generated by the Arduino IoT Cloud Thing "capstone-ta"
  https://create.arduino.cc/cloud/things/0387d665-4ebf-44d0-a292-d034191f1b4a

  Arduino IoT Cloud Variables description
  The following variables are automatically generated and updated when changes are made to the Thing

  float humi;
  float temp;
  int cleaner_rep;
  int food_lv;
  int w_lv_value;
  bool food_crit;
  bool isCleaning;
  bool isDisinfecting;
  bool man_cleaning;
  bool man_disinfecting;
  bool wtr_crit;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
// Library Imports
#include <Arduino.h>
#include <AccelStepper.h>
#include <Wire.h>
#include <uRTCLib.h>
#include <DHT.h>
#include <NewPing.h>
#include <Servo.h>

// Pin Definitions
#define SERVO_PIN 11
#define DHT11PIN 13
#define SOL_1 3    // Cleaning Water
#define SOL_2 4    // Drinking Water
#define WTR_PMP 9  // Disinfectant Sprayer
#define TRG_PIN 7
#define ECH_PIN 8
#define DIR_PIN 6
#define STEP_PIN 5
#define PUMP 2

// Constants
#define MOTOR_INTERFACE_TYPE 1
#define NO_TOUCH 0xFE
#define THRESHOLD 100
#define ATTINY1_HIGH_ADDR 0x78
#define ATTINY2_LOW_ADDR 0x77
#define DISINFECTION_DAY 5
#define HUMI_THRESHOLD 90
#define CLEANING_HOUR 15
#define MAX_DISTANCE 20
#define DHTTYPE DHT11

// Object Declarations
uRTCLib rtc(0x68);
DHT dht11(DHT11PIN, DHTTYPE);
AccelStepper stepper(MOTOR_INTERFACE_TYPE, STEP_PIN, DIR_PIN);
NewPing sonar(TRG_PIN, ECH_PIN, MAX_DISTANCE);
Servo servo;

// Memory Declarations
unsigned char low_data[8] = { 0 };
unsigned char high_data[12] = { 0 };
int lastDayChecked = -1;
int lastHourChecked = -1;
int hour, day, minute, dayOfWeek, lastDay;
unsigned long startTime;
bool timeoutOccurred;

// Function to get high section values from ATTINY1
void getHigh12SectionValue() {
  memset(high_data, 0, sizeof(high_data));
  Wire.requestFrom(ATTINY1_HIGH_ADDR, 12);
  while (12 != Wire.available())
    ;
  for (int i = 0; i < 12; i++) {
    high_data[i] = Wire.read();
  }
  delay(10);
}

// Function to get low section values from ATTINY2
void getLow8SectionValue() {
  memset(low_data, 0, sizeof(low_data));
  Wire.requestFrom(ATTINY2_LOW_ADDR, 8);
  while (8 != Wire.available())
    ;
  for (int i = 0; i < 8; i++) {
    low_data[i] = Wire.read();
  }
  delay(10);
}

// Function to read and calculate water level
void w_lv(int &w_lv_value) {
  int sensorvalue_min = 250;
  int sensorvalue_max = 255;
  int low_count = 0;
  int high_count = 0;
  uint32_t touch_val = 0;
  uint8_t trig_section = 0;

  getLow8SectionValue();
  getHigh12SectionValue();

  for (int i = 0; i < 8; i++) {
    if (low_data[i] >= sensorvalue_min && low_data[i] <= sensorvalue_max) {
      low_count++;
    }
  }
  for (int i = 0; i < 12; i++) {
    if (high_data[i] >= sensorvalue_min && high_data[i] <= sensorvalue_max) {
      high_count++;
    }
  }

  for (int i = 0; i < 8; i++) {
    if (low_data[i] > THRESHOLD) {
      touch_val |= 1 << i;
    }
  }
  for (int i = 0; i < 12; i++) {
    if (high_data[i] > THRESHOLD) {
      touch_val |= (uint32_t)1 << (8 + i);
    }
  }

  while (touch_val & 0x01) {
    trig_section++;
    touch_val >>= 1;
  }
  w_lv_value = trig_section * 5;

  Serial.print("Water level = ");
  Serial.print(w_lv_value);
  Serial.println("%");
  ArduinoCloud.update();
}

// Function for cleaning features
void cleaning() {
  isCleaning = true;
  ArduinoCloud.update();
  digitalWrite(SOL_1, HIGH);
  digitalWrite(PUMP, LOW);
  for (int i = 0; i < cleaner_rep; i++) {
    stepper.moveTo(8200);
    stepper.setSpeed(250);
    while (stepper.distanceToGo() != 0) {
      stepper.runSpeedToPosition();
    }
    delay(100);
    stepper.moveTo(0);
    stepper.setSpeed(250);
    while (stepper.distanceToGo() != 0) {
      stepper.runSpeedToPosition();
    }
    delay(100);
  }
  digitalWrite(SOL_1, LOW);
  digitalWrite(PUMP, HIGH);
  isCleaning = false;
  ArduinoCloud.update();
}

// Function for disinfecting features
void disinfection() {
  static unsigned long startTime = 0;
  static bool isRunning = false;

  if (!isRunning) {
    isDisinfecting = true;
    ArduinoCloud.update();
    digitalWrite(WTR_PMP, LOW);
    startTime = millis();
    isRunning = true;
  }
  while (isRunning) {
    if (isRunning && millis() - startTime >= 3000) {
      digitalWrite(WTR_PMP, HIGH);
      isDisinfecting = false;
      ArduinoCloud.update();
      isRunning = false;
    }
  }
}

// Function to move the servo motor to 180 degrees
void moveServo() {
  servo.write(180);
}

// Function to move the servo motor back to 0 degrees
void moveServoBack() {
  servo.write(0);
}

// Function to read the food level using sonar
void readFood(int &food_lv) {
  int val = sonar.ping_cm();
  Serial.print("Food_CM :");
  Serial.println(val);
  food_lv = map(val, 0, 18, 100, 0);
  Serial.print("Food Level: ");
  Serial.print(food_lv);
  Serial.println("%");
  ArduinoCloud.update();
}

// Function to read the RTC values
void rtcRead(int &dayOfWeek, int &day, int &hour, int &minute) {
  rtc.refresh();
  int year = rtc.year();
  int month = rtc.month();
  day = rtc.day();
  dayOfWeek = rtc.dayOfWeek();
  hour = rtc.hour();
  minute = rtc.minute();
  int second = rtc.second();

  Serial.print("RTC DateTime: ");
  Serial.print(year);
  Serial.print('/');
  Serial.print(month);
  Serial.print('/');
  Serial.print(day);

  Serial.print(' ');

  Serial.print(hour);
  Serial.print(':');
  Serial.print(minute);
  Serial.print(':');
  Serial.print(second);

  Serial.print(" DOW: ");
  Serial.print(dayOfWeek);

  Serial.println();
}

// Function to read temperature and humidity values
void readTempHumi(float &humi, float &temp) {
  humi = dht11.readHumidity();
  temp = dht11.readTemperature();
  Serial.print(F("Humidity: "));
  Serial.print(humi);
  Serial.print(F("%  Temperature: "));
  Serial.print(temp);
  Serial.print(F("Â°C "));
  Serial.println();
}

// Setup function
void setup() {
  Serial.begin(115200);
  delay(1500);

  // Initialize IoT Cloud properties
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  // Debugging info
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  // Initialize Wire and RTC
  Wire.begin();
  URTCLIB_WIRE.begin();
  dht11.begin();

  // Initialize pins
  pinMode(SOL_1, OUTPUT);
  digitalWrite(SOL_1, LOW);
  pinMode(SOL_2, OUTPUT);
  digitalWrite(SOL_2, LOW);
  pinMode(WTR_PMP, OUTPUT);
  digitalWrite(WTR_PMP, HIGH);
  pinMode(PUMP, OUTPUT);
  digitalWrite(PUMP, HIGH);

  rtc.set(0,58,14,1,11,8,24);

  // Initialize servo
  servo.attach(SERVO_PIN);
  servo.write(0);

  // Initialize stepper motor
  stepper.setCurrentPosition(0);
  stepper.setMaxSpeed(1000);
  stepper.setSpeed(250);
  rtcRead(dayOfWeek, day, hour, minute);
  readTempHumi(humi, temp);
}

// Loop function
void loop() {
  ArduinoCloud.update();
  startTime = millis();
  rtcRead(dayOfWeek, day, hour, minute);
  readTempHumi(humi, temp);
  food_crit = false;
  wtr_crit = false;
  isCleaning = false;
  isDisinfecting = false;

  readFood(food_lv);
  // Check food level
  startTime = millis();
  timeoutOccurred = false;

  while (true) {
    ArduinoCloud.update();
    readFood(food_lv);

    if (food_lv <= 25) {
      food_crit = true;
      ArduinoCloud.update();
      moveServo();

      while (food_lv <= 95) {
        readFood(food_lv);                   // Ensure food level is updated within the loop
        if (millis() - startTime > 10000) {  // Timeout after 10 seconds
          timeoutOccurred = true;
          break;
        }
      }
      moveServoBack();
    } else {
      food_crit = false;
      ArduinoCloud.update();
      break;  // Exit the outer loop if food level is above 25
    }

    if (timeoutOccurred) {
      break;  // Exit the outer loop if timeout occurred
    }
  }

  w_lv(w_lv_value);
  // Check water level
  startTime = millis();
  timeoutOccurred = false;

  while (true) {
    w_lv(w_lv_value);
    if (w_lv_value <= 25) {
      wtr_crit = true;
      ArduinoCloud.update();
      digitalWrite(SOL_2, HIGH);
      digitalWrite(PUMP, LOW);
      Serial.print("Mengisi Minum");

      while (w_lv_value <= 30) {
        w_lv(w_lv_value);
        if (millis() - startTime > 10000) {  // Timeout after 10 seconds
          timeoutOccurred = true;
          break;
        }
      }
      digitalWrite(SOL_2, LOW);
      digitalWrite(PUMP, HIGH);
    } else {
      wtr_crit = false;
      ArduinoCloud.update();
      break;
    }

    if (timeoutOccurred) {
      break;  // Exit the outer loop if timeout occurred
    }
  }

  rtcRead(dayOfWeek, day, hour, minute);
  // // Cleaning and disinfection
  if (hour != lastHourChecked) {
    lastHourChecked = hour;
    if (hour == CLEANING_HOUR) {
      cleaning();
      if (dayOfWeek == DISINFECTION_DAY) {
        if (humi <= HUMI_THRESHOLD) {
          disinfection();
        }
      }
    }
  }
}

/*
  Since CleanerRep is READ_WRITE variable, onCleanerRepChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onCleanerRepChange() {
}

/*
  Since ManCleaning is READ_WRITE variable, onManCleaningChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onManCleaningChange() {
  if (man_cleaning) {  // Execute only if the value is true
    cleaning();
  }
}

/*
  Since ManDisinfecting is READ_WRITE variable, onManDisinfectingChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onManDisinfectingChange() {
  if (man_disinfecting) {  // Execute only if the value is true
    disinfection();
  }
}
